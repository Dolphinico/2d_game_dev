Каждый игрок управляет кораблем, который находится в середине нижнего края экрана
Игрок перемещает корабль вправо и влево клавишами управления или курсором; 
клавиша «пробел» используется для стрельбы.

В начале игры флот пришельцев находится в верхней
части экрана и постепенно опускается вниз, также смещаясь в сторону Игрок выстрелами
уничтожает пришельцев.

Если ему удается сбить всех пришельцев, появляется новый флот,
который движется быстрее предыдущего.
Если пришелец сталкивается с кораблем игрока или доходит до нижнего края экрана, игрок теряет корабль.
Если игрок теряет все три корабля,игра заканчивается.

///f_project_screen_description_of_code///

Игра Alien Invasion начинается с определения функции run_game(). 
Строка pygame.init() инициализирует настройки, необходимые Pygame для нормальной работы. 
Вызов pygame.display.set_mode() создает отображаемую область screen, на которой прорисовываются все графические элементы игры.
Аргумент (1280, 720) представляет собой кортеж, определяющий размеры игрового окна.
Передавая эти размеры pygame.display.set_mode(), мы создаем игровое окно с шириной 1280 пикселов и высотой 720 пикселов.
Объект screen называется поверхностью (surface). 
Поверхность в Pygame представляет часть экрана, на которой отображается игровой элемент.
Каждый элемент в игре (например, пришелец или корабль игрока) представлен поверхностью.
Поверхность, возвращаемая display.set_mode(), представляет все игровое окно.
При активизации игрового цикла анимации эта поверхность автоматически перерисовывается при каждом проходе цикла.
Процессом игры управляет цикл while, который содержит цикл событий и код,
управляющий обновлениями экрана.
Событием называется действие, выполняемое пользователем во время игры (например, нажатие клавиши или перемещение мыши).
Чтобы наша программа реагировала на события, мы напишем цикл событий для прослушивания событий и выполнения соответствующей операции
в зависимости от типа произошедшего события. 
Этим циклом событий является цикл for.
Чтобы получить доступ к событиям, обнаруженным Pygame, мы используем метод pygame.event.get().
При любом событии клавиатуры или мыши отрабатывает цикл for.
В этом цикле мы пишем серию команд if для обнаружения и обработки конкретных событий.
Например, когда игрок щелкает на кнопке закрытия игрового окна, программа обнаруживает событие pygame.QUIT, и программа вызывает метод sys.exit() для выхода из игры.
Вызов pygame.display.flip()приказывает Pygame отобразить последний отрисованный экран. 
В данном случае при каждом выполнении цикла while будет отображаться пустой экран со стиранием старого экрана, так что виден будет только новый экран.
При перемещении игровых элементов вызов pygame.display.flip() будет постоянно обновлять экран,
отображая игровые элементы в новых позициях и скрывая старые изображения; таким образом создается иллюзия плавного движения.

///f_project_description_of_color_code///

Сначала программа создает цвет фона и сохраняет его в переменной bg_color.
Цвет достаточно задать только один раз, поэтому его значение определяется до входа в основной цикл while.
Цвета в Pygame задаются в схеме RGB: тройками интенсивности красной, зеленой и синей составляющих цвета.
Значение каждой составляющей лежит в диапазоне от 0 до 255.
Цветовое значение (255, 0, 0) соответствует красному цвету, (0, 255,0) — зеленому и (0, 0, 255) — синему.
Разные сочетания составляющих RGB позволяют создать до 16 миллионов цветов.
В цветовом значении (112, 128, 144) красная, синяя и зеленая составляющие смешиваются в равных долях, давая светло-серый цвет фона.
В точке  экран заполняется цветом фона. Для этого вызывается метод screen.fill(), получающий всего один аргумент: цвет фона.


///settings.py///

Чтобы внести изменения в игру, достаточно будет изменить некоторые значения в settings py вместо того, чтобы искать разные настройки в файлах.
Класс Settings импортируется в основной файл программы, после чего программа создает экземпляр Settings и сохраняет его в ai_settings после вызова pygame.init().
При создании экрана используются атрибуты screen_width и screen_height объекта ai_settings, после чего объект ai_settings
также используется дляполучения цвета фона при заполнении экрана.

///ссылка на полезную статью по работе с pygame///

https://habr.com/ru/post/347170/

///ship.py///

Сначала программа импортирует модуль pygame. Метод __init__() класса Ship получает два параметра: ссылку self и объект screen, на котором выводится корабль.
Загрузка изображения выполняется вызовом pygame.image.load(). 
Функция возвращает поверхность, представляющую корабль; полученный объект сохраняется в self.image.
После того как изображение будет загружено, метод get_rect() используется для получения атрибута rect поверхности.
При работе с объектом rect для вас доступны координаты x и y верхней, нижней, левой и правой сторон, а также центра.
Присваивая любые из этих значений, вы задаете текущую позицию прямоугольника.
Местонахождение центра игрового элемента определяется атрибутами center, centerx или centery прямоугольника.
Стороны определяются атрибутами top, bottom, left и right.
Для изменения горизонтального или вертикального расположения прямоугольника достаточно задать атрибуты x и y, содержащие координаты левого верхнего угла.

Корабль будет расположен в середине нижней стороны экрана. Для этого мы сначала сохраняем прямоугольник экрана в self.screen_rect,
а затем присваиваем self.rect.centerx (координата x центра корабля) значение атрибута centerx прямоугольника экрана.
Атрибуту self.rect.bottom (координата y низа корабля) присваивается значение атрибута bottom прямоугольника экрана.
Pygame использует эти атрибуты rect для позиционирования изображения, чтобы корабль был выровнен по центру, а его нижний край совпадал с нижним краем экрана.
Затем определяется метод blitme(), который выводит изображение на экранв позиции, заданной self.rect.

//outputing_ship_on_screen//

После создания экрана программа импортирует класс Ship и создает его экземпляр (с именем ship). 
Это должно происходить до начала основного цикла while, чтобы при каждом проходе цикла не создавался новый экземпляр корабля.
Чтобы перерисовать корабль на экране, мы вызываем ship.blitme() после заполнения фона, так что корабль выводится поверх фона.

///f_project_description_of_refactoring_adding_game_function_module///

//Рефакторинг модуля game_functions//

В больших проектах перед добавлением нового кода часто проводится рефакторинг уже написанного кода.
Рефакторинг упрощает структуру существующего кода и дальнейшее развитие проекта.
В этом разделе мы создадим новый модуль game_functions для хранения функций, обеспечивающих работу игры.
Модуль game_functions предотвратит чрезмерное разрастание f_project.py и сделает логику f_project.py более простой и понятной.

//Функция check_events()//

Начнем с перемещения кода управления событиями в отдельную функцию check_events().
Тем самым вы упростите run_game() и изолируете цикл управления событиями от остального кода.
Изоляция цикла событий позволит организовать управление событиями отдельно от других аспектов игры (например, обновления экрана).
Поместим check_events() в отдельный модуль с именем game_functions:
Этот модуль импортирует модули sys и pygame, используемые в цикле обработки событий.
После присваивания псевдонима gf - каждый раз модуль импортировать нет необходимости.


//Функция update_screen()//

Новая функция update_screen() получает три параметра: ai_settings, screen и ship. меняем цикл while из f_project.py вызовом update_screen()
Эти две функции упрощают цикл while и процесс дальнейшей разработки. Большая часть работы будет выполняться не в run_game(), а в модуле game_functions.

/// Обработка нажатия клавиш ///

Каждое событие идентифицируется методом pygame.event.get(),
поэтому в функции check_events() необходимо указать, какие события должны отслеживаться.
Каждое нажатие клавиши регистрируется как событие KEYDOWN.
Функции check_events() передается параметр ship, потому что корабль должен двигаться вправо при нажатии клавиши →.
Внутри check_events() в цикл событий добавляется блок elif для выполнения кода при обнаружении события KEYDOWN.
Чтобы проверить, является ли нажатая клавиша клавишей → (pygame.K_RIGHT), мы читаем атрибут event.key. 
Если нажата клавиша →, корабль перемещается вправо, для чего значение ship.rect.centerx увеличивается на 1.

Если игрок удерживает клавишу →, корабль должен двигаться вправо до тех пор,пока клавиша не будет отпущена.
Чтобы узнать, когда клавиша → будет отпущена,игра отслеживает событие pygame.KEYUP; таким образом,
реализация непрерывного движения будет основана на отслеживании событий KEYDOWN и KEYUP в сочетании с флагом moving_right.
В неподвижном состоянии корабля флаг moving_right равен False.
При нажатии клавиши → флагу присваивается значение True, а когда клавиша будет отпущена, флаг возвращается в состояние False.

Атрибут с именем moving_right и метод update()  нужен для проверки состояния флага moving_right.
Метод update() изменяет позицию корабля, если флаг содержит значение True. 
Этот метод будет вызываться каждый раз, когда вы хотите обновить позицию корабля.

Атрибут self.moving_right в методе __init__() и инициализируется его значением False.
Затем вызывается метод update(), который перемещает корабль вправо, если флаг равен True.

Передвежение влево создается аналагичным образом

/// В двух словах /// 

//f_project.py//

Главный файл программы создает ряд важных объектов, используемых ходе игры: настройки хранятся в ai_settings,
основная поверхность для вывода изображения хранится в screen, а экземпляр ship тоже создается в этом файле.
Также в alien_invasion py содержится главный цикл игры — цикл while с вызовами check_events(), ship.update() и update_screen().
Файл f_project.py — единственный файл, который должен запускаться для игры в f_project.
Все остальные файлы — settings.py, game_functions.py, ship.py — содержат код, который импортируется (прямо или косвенно) в этот файл.

//settings.py//

Файл settings.py содержит класс Settings.
Этот класс содержит только метод __init__(), инициализирующий атрибуты, которые управляют внешним видом и скоростью игры.

//game_functions.py//

Файл game_functions.py содержит набор функций, выполняющих основную работу в игре.
Функция check_events() обнаруживает события, представляющие интерес для игры (например, нажатия и отпускания клавиш),
и обрабатывает все эти типы событий при помощи вспомогательных функций check_keydown_events() и check_keyup_events().
Модуль game_functions также содержит функцию update_screen(), которая перерисовывает экран при каждом проходе основного цикла.

//ship.py//
Файл ship py содержит класс Ship. В этом классе определен метод __init__(),
метод update() для управления позицией корабля и метод blitme() для вывода
изображения корабля на экран.


